diff --git a/oslo/middleware/openstack/common/context.py b/oslo/middleware/openstack/common/context.py
index b612db7..e184d8f 100644
--- a/oslo/middleware/openstack/common/context.py
+++ b/oslo/middleware/openstack/common/context.py
@@ -41,7 +41,7 @@ class RequestContext(object):
     def __init__(self, auth_token=None, user=None, tenant=None, domain=None,
                  user_domain=None, project_domain=None, is_admin=False,
                  read_only=False, show_deleted=False, request_id=None,
-                 instance_uuid=None):
+                 instance_uuid=None, global_request_id=None):
         self.auth_token = auth_token
         self.user = user
         self.tenant = tenant
@@ -55,6 +55,17 @@ class RequestContext(object):
         if not request_id:
             request_id = generate_request_id()
         self.request_id = request_id
+        self.global_request_id = global_request_id
+
+    @property
+    def global_id(self):
+        """Return a sensible value for global_id to pass on.
+
+        When we want to make a call with to another service, it's
+        important that we try to use global_request_id if available,
+        and fall back to the locally generated request_id if not.
+        """
+        return self.global_request_id or self.request_id
 
     def to_dict(self):
         user_idt = (
@@ -74,6 +85,7 @@ class RequestContext(object):
                 'show_deleted': self.show_deleted,
                 'auth_token': self.auth_token,
                 'request_id': self.request_id,
+                'global_request_id': self.global_request_id,
                 'instance_uuid': self.instance_uuid,
                 'user_identity': user_idt}
 
@@ -90,7 +102,8 @@ class RequestContext(object):
             read_only=ctx.get("read_only", False),
             show_deleted=ctx.get("show_deleted", False),
             request_id=ctx.get("request_id"),
-            instance_uuid=ctx.get("instance_uuid"))
+            instance_uuid=ctx.get("instance_uuid"),
+            global_request_id=ctx.get("global_request_id"))
 
 
 def get_admin_context(show_deleted=False):
diff --git a/oslo/middleware/request_id.py b/oslo/middleware/request_id.py
index f3a22c1..aec233f 100644
--- a/oslo/middleware/request_id.py
+++ b/oslo/middleware/request_id.py
@@ -12,6 +12,7 @@
 #    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 #    License for the specific language governing permissions and limitations
 #    under the License.
+import re
 
 import webob.dec
 
@@ -20,21 +21,45 @@ from oslo.middleware.openstack.common import context
 
 
 ENV_REQUEST_ID = 'openstack.request_id'
+GLOBAL_REQ_ID = 'openstack.global_request_id'
 HTTP_RESP_HEADER_REQUEST_ID = 'x-openstack-request-id'
+INBOUND_HEADER = 'X-Openstack-Request-Id'
+ID_FORMAT = (r'^req-[a-f0-9]{8}-[a-f0-9]{4}-'
+             r'[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$')
 
 
-class RequestId(base.Middleware):
+class RequestIdMiddleware(base.Middleware):
     """Middleware that ensures request ID.
 
     It ensures to assign request ID for each API request and set it to
     request environment. The request ID is also added to API response.
     """
 
+    # if compat_headers is set, we also return the request_id in those
+    # headers as well. This allows projects like Nova to adopt
+    # oslo.middleware without impacting existing users.
+    compat_headers = []
+
+    def set_global_req_id(self, req):
+        gr_id = req.headers.get(INBOUND_HEADER, "")
+        if re.match(ID_FORMAT, gr_id):
+            req.environ[GLOBAL_REQ_ID] = gr_id
+            # TODO(sdague): it would be nice to warn if we dropped a bogus
+            # request_id, but the infrastructure for doing that isn't yet
+            # setup at this stage.
+
     @webob.dec.wsgify
     def __call__(self, req):
+        self.set_global_req_id(req)
+
         req_id = context.generate_request_id()
         req.environ[ENV_REQUEST_ID] = req_id
         response = req.get_response(self.application)
-        if HTTP_RESP_HEADER_REQUEST_ID not in response.headers:
-            response.headers.add(HTTP_RESP_HEADER_REQUEST_ID, req_id)
+
+        return_headers = [HTTP_RESP_HEADER_REQUEST_ID]
+        return_headers.extend(self.compat_headers)
+
+        for header in return_headers:
+            if header not in response.headers:
+                response.headers.add(header, req_id)
         return response
